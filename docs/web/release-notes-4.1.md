---
title: Release notes of the 4.1 version of `TFEL`, `MFront` and `MTest`
author: Thomas Helfer
date: 2022
lang: en-EN
numbersections: true
documentclass: article
from: markdown+tex_math_single_backslash
geometry:
  - margin=2cm
papersize: a4
link-citations: true
colorlinks: true
figPrefixTemplate: "$$i$$"
tblPrefixTemplate: "$$i$$"
secPrefixTemplate: "$$i$$"
eqnPrefixTemplate: "($$i$$)"
---

The page describes the new functionalities of Version 4.1 of the
`TFEL` project.

# Known incompatiblities

## New reserved keywords in `MFront`

As described in Section @sec:tfel_4.1:mfront:initialize_functions,
behaviours can now declare initialize functions. Each initialize
function has a dedicated name. If `@initialize_function@` be the name of
a initialize function, `MFront` will automatically register
`execute@initialize_function@IntializeFunction` as a member name.

As described in Section @sec:tfel_4.1:mfront:postprocessings, behaviours
can now declare post-processings. Each post-processing has a dedicated
name. If `@postprocessing@` be the name of a post-processing, `MFront`
will automatically register `execute@postprocessing@PostProcessing` as a
member name.

# `TFEL/System` improvements

## Improvement to the `ExternalLibraryManager` class

### Retrieving initialize functions generated by the `generic` interface {#sec:tfel_4.1:system:elm:initialize_functions}

The `generic` interface generates a function dedicated for each
initialize function and each modelling hypothesis supported (see Section
@sec:tfel_4.1:mfront:initialize_functions for details about
initialize functions).

The `ExternalLibraryManager` class now exposes the following methods:

- `getGenericBehaviourInitializeFunctions`, which returns the
  initialize functions associated with a behaviour.
- `getGenericBehaviourInitializeFunction`, which returns the
  function implementing a initialize function.
- `getGenericBehaviourInitializeFunctionOutputs`, which returns the
  outputs of a initialize function function.
- `getGenericBehaviourInitializeFunctionOutputs`, which returns the
  types of the outputs of a initialize function function.

### Retrieving post-processing functions generated by the `generic` interface {#sec:tfel_4.1:system:elm:postprocessings}

The `generic` interface generates a function dedicated for each
post-processing and each modelling hypothesis supported (see Section
@sec:tfel_4.1:mfront:postprocessings for details about
post-processings).

The `ExternalLibraryManager` class now exposes the following methods:

- `getGenericBehaviourPostProcessingFunctions`, which returns the
  post-processings associated with a behaviour.
- `getGenericBehaviourPostProcessingFunction`, which returns the
  function implementing a post-processing.
- `getGenericBehaviourPostProcessingFunctionOutputs`, which returns the
  outputs of a post-processing function.
- `getGenericBehaviourPostProcessingFunctionOutputs`, which returns the
  types of the outputs of a post-processing function.

### The `hasTemperatureBeenRemovedFromExternalStateVariables` method

In previous versions of `MFront`, the temperature was automatically
defined as the first external state variable by domain specific
languages handling behaviours.

By conventions, for consistency with behaviour interfaces derived from
the `Abaqus`' `UMAT` interface, the temperature was removed from the
list of external state variables exported by the behaviour. This list
can be retrieved using the `getUMATExternalStateVariablesNames` method
of the `ExternalLibraryManager` class.

Following Issue #50 (see Sections
@sec:tfel:4.1:mfront:global_options:temperature_as_first_external_state_variable
and @sec:tfel:4.1:issue:50), this automatic declaration is now optional.

For backward compatibility, the `getUMATExternalStateVariablesNames` method
still return the list of external state variables without the
temperature. To know if the temperature was removed, the user must call
the `hasTemperatureBeenRemovedFromExternalStateVariables` method.

In pratice, if the `hasTemperatureBeenRemovedFromExternalStateVariables`
method returns `true`, the full list of external state variables is
given by the temperature followed by the list of external state
variables returned by the `getUMATExternalStateVariablesNames` method.

## Improvements to the `ExternalBehaviourDescription` class

The `ExternalBehaviourDescription` class now have
`hasTemperatureBeenRemovedFromExternalStateVariables` boolean public
data member which states if the temperature was removed from the list of
external state variables.

# `MFront` improvements

## Options to domain specific languages

Domain specific language can have options which can modify their
default behaviour.

### Treat parameters as static variables {#sec:tfel:4.1:mfront:global_options:parameters_as_static_variables}

The boolean option `parameters_as_static_variables` modifies the way
parameters are treated. This option can be declared as follows:

~~~~{.cxx}
@DSL Default{parameters_as_static_variables : true};
~~~~

By default, `MFront` behaves as if this option was set to `false`.

If `true`, the parameters will be treated as static variables. In
particular, the values of the parameters can not be changed as runtime.
From the solver point of view, the behaviour does not declare any
parameter.

If the current domain specific language calls other domain specific
languages (for example, a behaviour calling an external material
property), the value of this option is automatically passed to those
domain specific languages (unless superceeded by global options, as
detailled in Section @sec:tfel_4.1:mfront:global_dsl_options).

### Specifying a build identifier {#sec:tfel:4.1:mfront:global_options:build_identifier}

In previous versions, a build identifier could be specified using the
`TFEL_BUILD_ID` environment variable.

The `build_identifier` option is another way of specifying the build
identifier, as follows:

~~~~{.cxx}
@DSL IsotropicPlasticMisesFlow{
  build_identifier : "Cyrano-3.4"
};
~~~~

However, the `build_identifier` is not meant to be directly specified in
the `MFront` source file. It shall rather be defined on the command line
(see Section @sec:tfel_4.1:mfront:global_dsl_options).

### Automatic declaration of the temperature as the first external state variable for behaviours {#sec:tfel:4.1:mfront:global_options:temperature_as_first_external_state_variable}

In previous versions of `MFront`, the temperature was automatically
defined as the first external state variable by domain specific
languages handling behaviours, as this is required by most behaviour
interfaces derived from `Abaqus`' `UMAT` interface.

This automatic declaration can now be disabled using the
`automatic_declaration_of_the_temperature_as_first_external_state_variable`
boolean option, as follows:

~~~~{.cxx}
@DSL IsotropicPlasticMisesFlow{
  automatic_declaration_of_the_temperature_as_first_external_state_variable : false
};
~~~~

By default, `MFront` behaves as if this option was set to `true`.
Currently, only the generic interface supports behaviours which do not
declare the temperature a the first external state variable.

#### Special case of specialized domain specific languages

`IsotropicMisesCreep`, `IsotropicMisesPlasticFlow`,
`IsotropicStrainHardeningMisesCreep` and `MultipleIsotropicMisesFlows`
domain specific languages used to automatically declare the temperature
at the middle of the time step in a local variable named `T_`. This
declaration is disabled if the
`automatic_declaration_of_the_temperature_as_first_external_state_variable`
option is set to `false`.

### Disabling initialization of parameters from text file {#sec:tfel:4.1:mfront:global_options:parameters_initialization_from_file}

By default, parameters may be initialized from a text file in the
current directory, if this text file exists. This feature is implemented
and enabled by default for behaviours. For material properties, this
feature is implemented by some interfaces (`Cast3M`, `Cyrano`, `Octave`,
`Python`).

This behaviour can now be changed by using the
`parameters_initialization_from_file` boolean option.

### Specifying the default out of bounds policy {#sec:tfel:4.1:mfront:global_options:default_out_of_bounds_policy}

In previous versions, the default out of bound policy was
`tfel::material::None`, which meant that nothing is done when a variable
is out of its bound.

This behaviour can now be changed by using the
`default_out_of_bounds_policy` string option which can take the values
`None`, `Warning` or `Strict`.

### Disabling runtime change of the out of bounds policy {#sec:tfel:4.1:mfront:global_options:out_of_bounds_policy_runtime_modification}

The `out_of_bounds_policy_runtime_modification` boolean option states if
the out of bounds policy can be changed at runtime. By default, this
option is `true`.

If `true`, many interfaces (`Cast3M`, `Python`, `Java`, etc..) uses
environment variables to modify the out of bounds policy.

### Defining global options from the command line {#sec:tfel_4.1:mfront:global_dsl_options}

Options passed to domain specific languages can be defined globally
using one of the following command line arguments:

- `--dsl-option`, which allows to define an option for all domain
  specific languages.
- `--material-property-dsl-option`, which allows to define an option for
  all domain specific languages related to material properties.
- `--behaviour-dsl-option`, which allows to define an option for all
  domain specific languages related to behaviours.
- `--model-dsl-option`, which allows to define an option for all domain
  specific languages related to models.

The options defined by command line arguments are merged with the
options defined inside the `MFront` file. In case of conflicts, an
option defined on the command-line overwrites the option defined in the
`MFront` file.

#### Example of usage

~~~~{.cxx}
$ mfront --obuild --interface=generic                          \
    --behaviour-dsl-option=parameters_as_static_variables:true \
    Plasticity.mfront
~~~~

### Retrieving the list of options associated with a domain specific language {#sec:tfel_4.1:mfront:list_dsl_options}

The list of options associated with a domain specific language can be
retrieved using the `--list-dsl-options` command line argument as
follows:

~~~~{.bash}
$ mfront --list-dsl-options=RungeKutta
- parameters_as_static_variables: boolean stating if the parameter shall be treated as static variables.
- automatic_declaration_of_the_temperature_as_first_external_state_variable: boolean stating if the temperature shall be automatically declared as an external state variable.
~~~~

## Initialize functions for behaviours {#sec:tfel_4.1:mfront:initialize_functions}

The `@InitializeFunction` keyword introduces a code block that can be
used to initialize internal state variables at the very beginning of the
computation. Initalize functions may have user so-called
*initialize funtion variables*.

In this version, only the `generic` interface generates functions
associated with initialize functions (See Section
@sec:tfel_4.1:system:elm:initialize_functions to see how to retrieve
the initialize functions generated by the `generic` interfaces).

Because initialize functions are called before any behaviour
integration, special care to the meaning of the variables must be taken:

- The gradients and external state variable will have their values at
  the beginning of the time step and their increments will be null.
- The thermodynamic forces will have their values at the beginning of
  the time step.
- The state variables and auxiliary state variables will have undefined
  values. The associated increments, if defined, will be null.

Concerning material properties, they have their values at the beginning
of the time step.

> **About initialisation of local variables**
>
> The code block defined by the `@InitLocalVariables` code block
> shall be called before the execution of an initialize function.

### Example of usage

The following code defines an initializer function which initializes the
elastic strain from the value of stress:

~~~~{.cxx}
@InitializeFunction ElasticStrainFromInitialStress{
  const auto K = 2 / (3 * (1 - 2 * nu));
  const auto pr = trace(sig) / 3;
  const auto s = deviator(sig);
  eel = eval((pr / K) * Stensor::Id() + s / mu);
}
~~~~

### About initialize function variables

Initialize function variables are introduced by the
`@InitializeFunctionVariable` keyword.

Initialize function variables are only defined in initialize functions,
and can't be used in the other code blocks.

Contrary most variables (internal state variables, external state
variables, etc.), initialize function variables can be defined after the
first code block. However, care must be taken to declare initialize
function variables **before** their use in an initialize function.

Note that an initialize function variable can be used in differents
initialize function.

## Post-processings of behaviours {#sec:tfel_4.1:mfront:postprocessings}

The `@PostProcessing` keyword introduces a code block that can be used
to perform computations independently of the behaviour integration. The
outputs of post-processings are stored in so-called *post-processing
variables*.

Post-processings are typically meant to be called at the end of a time
step, when the equilibrium has been reached.

In this version, only the `generic` interface generates functions
associated with post-processings (See Section
@sec:tfel_4.1:system:elm:postprocessings to see how to retrieve the
post-processing functions generated by the `generic` interfaces).

Because post-processings are called independently of the behaviour
integration step, special care to the meaning of the variables must be
taken:

- The thermodynamic forces will have their values at the end of the time
  step.
- The state variables and auxiliary state variables will have their
  values at the end of the time step. The associated increments, if
  defined, will be null.

The values of the thermodynamic forces, state variables, auxiliary state
variables at the beginning of the time step are available in a special
data structure named `initial_state`.

Concerning material properties, they have their values at the end of the
time step as usual.

For the gradients and external state variables have their values at the
end of the time step. Their values at the beginning of the time step are
avaiable in the `initial_state` data structure. Their increments have
their usual values.

> **About initialisation of local variables**
>
> The code block defined by the `@InitLocalVariables` code block
> shall be called before the execution of the post-processing.
> However, this code block will be called with the thermodynamic forces, 
> state variables, auxiliary state variables at the end of the time step.

### Example of usage

The following code defines a post-processing computing the principal
strain at the end of the time step:

~~~~{.cxx}
//! principal strains
@PostProcessingVariable tvector<3u,strain> εᵖ;
εᵖ.setEntryName("PrincipalStrain");
//! compute the principal strain
@PostProcessing PrincipalStrain {
  εᵖ = eto.computeEigenValues();
}
~~~~

### About post-processing variables

Post-processing variables are introduced by the
`@PostProcessingVariable` keyword.

Post-processing variables are only defined in post-processings, and
can't be used in the other code blocks.

Contrary most variables (internal state variables, external state
variables, etc.), post-processing variables can be defined after the
first code block. However, care must be taken to declare post-processing
variables **before** their use in a post-processing.

Note that a post-processing variable can be used in differents
post-processings. Typically, one may compute the principal strains in a
dedicated post-processing and in a post-processing computing the
principal strains and the strain eigen vectors.

# `MTest` improvements

## Support for `madnex` file {#sec:tfel:4.1:mtest:madnex_support}

### Exporting an `MTest` test to a `madnex` file

The `TFELMTest` library exposes a data structure named `TestDescription` which
describes an `MTest` file and two functions called respectively
`loadMTestFileContent` and `write`.

This data structure and functions are exported in `python`, as described
in Section @sec:tfel:4.1:python:mtest:export_mtest_file. Section
@sec:tfel:4.1:python:mtest:export_mtest_file:usage provides an example
of use.

#### The `TestDescription` data structure {#sec:tfel:4.1:mtest:TestDescription}

The `TestDescription` data structure exposes the following data members:

- `author`, which describes the author of the test.
- `date`, which describes the date at which the test has been created.
- `scheme`, which describes the type of test. Valid values are `mtest`
  and `ptest`.
- `description`, which describes a description of the test.
- `behaviour`, name of the behaviour to which the test is associated.
  This data member is **required** to export the file in the `madnex`
  file format.
- `material`, name of the material to which the test is associated. This
  data member can be empty.
- `content`, content of the `MTest` file. This content can be filled
  from an existing `MTest` file using the `loadMTestFileContent`
  function.

#### The `loadMTestFileContent` function {#sec:tfel:4.1:mtest:loadMTestFileContent}

The `loadMTestFileContent` function loads the content of an `MTest` file
and stores it in the `content` data member of a `TestDescription` data
structure.

#### The `write` function {#sec:tfel:4.1:mtest:write}

The `write` function exports an `MTest` test, described by a
`TestDescription` data structure, to a file.

The file format is deduced from the extension of the file.

Currently, only extensions associated with the [`madnex` file
format](https://github.com/thelfer/madnex) are supported if `TFEL` is
compiled with support of this file format. Those extensions are: `mdnx`,
`madnex` (deprecated) or `edf` (experimental data file, deprecated).
Note that the behaviour member of the metadata must be specified for
export in the `madnex` file format.

#### Best practices

We highly recommend to use the following substitution variables when
defining the test:

- `@interface@`, which is meant to be replaced by the interface to be
  used. This is very handy if the test can be run for different
  interfaces
- `@library@`, which is meant to be replaced by the path to the shared
  library containing the tested behaviour.
- `@behaviour@`, which contains the name of the function implementing
  the behaviour for the considered interface.

### Executing a test stored in a `madnex` file

To execute a test stored in a `madnex` file, the user must specify:

- the name of the `madnex` file
- the name of the test using the `--test` (or `-t`) command line
  argument.
- the name of the behaviour to which the test is associated using the
  `--behaviour` (or `-b`) command line argument.
- the name of the material is the behaviour to which the test is
  associated is associated with a material using the `--material` (or
  `-m`) command line argument. If the material is not specified, or if
  the special material name `<none>` is used, the behaviour associated
  with the test is assumed not associated with any material.

Note that the `--test` (or `-t`) command line argument can accept
regular expressions to select as set of tests.

#### Example of usage

The following example executes the UniaxialTensileTest` test 
associated with the `Plasticity` behaviour (and not attached to any
material) using the behaviour `cyranoplasticity` compiled with the
`cyrano` interface in a shared library `libCyranoBehaviours.so` located
in the `src` subdirectory and stored in the `Plasticity.mdnx` file:

~~~~{.bash}
$ mtest  --behaviour=Plasticity --test=UniaxialTensileTest        \
         --@interface@=cyrano --@behaviour@="'cyranoplasticity'"  \
         --@library@="'src/libCyranoBehaviours.so'"               \
         Plasticity.mdnx
~~~~

### Execution all tests associated with a behaviour stored in a `madnex` file

The user can execute all tests associated with a behaviour using the
`--all-tests` command line arguments. The user must specify the name of
the behaviour (using the `--behaviour` (or `-b`) command line argument)
and optionally the name of the material (using the `--material` (or
`-m`) command line argument).

~~~~{.bash}
$ mtest  --behaviour=Plasticity --@interface@=cyrano \
         --@behaviour@="'cyranoplasticity'"          \
         --@library@="'src/libCyranoBehaviours.so'"  \ 
         --all-tests Plasticity.mdnx                 \
~~~~

The `--all-tests` command line argument is equivalent to `--test=".+"`.

### Alternative way to select a single test in a `madnex` file

`mtest` allows to select a test inside a `madnex` file using the
following path syntax:

~~~~
madnex:<file>:<material>:<behaviour>:<test>
~~~~

where:

- `<file>` is the path to the `madnex` file.
- `<material>` is the name of the material considered. This name can be
  empty or `<none>` if the considered test is not
  associated to a material.
- `<behaviour>` is the name of the behaviour
- `<test>` is the name of the test

## Support for a boundary condition modelling the effet of a mandrel in pipe modelling {#sec:tfel_4.1:mtest:mandrel}

The effect of a non-deformable mandrel located inside the pipe can be
modelled by defining the evolution of its radius \(R_{m}\) using the
`@MandrelRadiusEvolution` keyword. The inner radius \(R_{i}\) will then
satisfy the following unilateral boundary condition:

\[
R_{i} - R_{m} \geq 0
\]

This boundary condition is imposed by using a Lagrange multiplier. Its
value is given by the contact pressure in the output file. The total
pressure applied to the inner surface of the pipe is given by the sum of
the imposed pressure (if any) and the contact pressure. Only the imposed
inner pressure is used to compute the end cap effect.

This boundary condition is not compatible with:

- boundary conditions imposing the evolution of the inner radius of the
  pipe or the outer radius of the pipe.
- the modelling of a tight pipe. 

### Axial binding

If the evolution of the axial growth of the mandrel is defined using the
`@MandrelAxialGrowthEvolution` keyword, an axial binding between the
mandrel and the pipe is assumed, i.e. the difference between the axial
growth of the pipe \(\varepsilon^{p}_{zz}\) and the axial growth of the
mandrel \(\varepsilon^{p}_{zz}\) is assumed to be constant to its value
when the contact between the mandrel and the pipe is detected:

\[
\varepsilon^{p}_{zz}-\varepsilon^{m}_{zz}=\textrm{Cste}
\]

This axial boundary condition is not compatible with the boundary
condition imposing the evolution of the axial growth of the pipe.

## Wrappers around `3D` behaviours {#sec:tfel_4.1:mtest:small_strain_tridimensional_behaviour_wrapper}

The `SmallStrainTridimensionalBehaviourWrapper` class allows to wrap a
tridimensional behaviour into a behaviour usable in one of the following
modelling hypotheses:

- axisymmetrical generalised plane strain,
- generalised plane strain,
- plane strain.

Shear components of the strain tensor which are not meaningful for the
targeted modelling hypothesis are set to zero.

After the behaviour integration, only the meaningful components of the
stress tensor and stiffness matrix are retained.

### Treatment of the internal state variables

The internal state variables are all declared as scalars.

For instance, let us assume that the `3D` behaviour declares an internal
state variable called `s`. In this case, the wrapped behaviour will then
declared `6` internal state variables associated with `s` named
respectively `sXX`, `sYY`, `sZZ`, `sXY`, `sXZ`, `sYZ`.

### Usage in `MTest`

The following code shows how to wrap a tridimensional behaviour to be
used under the axisymmetrical plane strain modelling hypothesis:

~~~~{.cxx}
// Choice of the modelling hypothesis
@ModellingHypothesis "AxisymmetricalGeneralisedPlaneStrain";
// Declaration of the behaviour
@Behaviour<
    generic,                                   // interface name
    SmallStrainTridimensionalBehaviourWrapper> // wrapper
    "src/libBehaviour.so" "ImplicitNorton";
~~~~

### Usage in the `mtest` `python` module

The following code shows how to load a tridimensional behaviour and how
to wrap this behaviour to be used in plane strain:

~~~~{.python}
import mtest
import tfel.material
h = tfel.material.ModellingHypothesis.TRIDIMENSIONAL
b1 = mtest.Behaviour('generic', 'src/libBehaviour.so',
                     'ImplicitNorton', h)
# ['ElasticStrain', 'p']
print(b1.getInternalStateVariablesNames())
b2 = mtest.Behaviour(wrapper = 'SmallStrainTridimensionalBehaviourWrapper',
                     library = 'src/libBehaviour.so',
                     function = 'ImplicitNorton',
                     hypothesis = 'PlaneStrain')
# ['ElasticStrainXX', 'ElasticStrainYY', 'ElasticStrainZZ',
#  'ElasticStrainXY', 'ElasticStrainXZ', 'ElasticStrainYZ', 'p']
print(b2.getInternalStateVariablesNames())
~~~~

## A more flexible declaration of the rotation matrix {#sec:tfel_4.1:mtest:rotation_matrix}

The `@RotationMatrix` keyword now has a `Direction` option which now let
the user specify:

- a \(2D\) vector giving the first direction of orthotropy in modelling
  hypotheses of space dimension \(2\).
- two \(3D\) vectors giving respectively the first and second directions
  of orthotropy under the tridimensional modelling hypothesis.

The given vectors are not required to be normalised. In the \(3D\) case,
the second vector is not required to be orthogonal to the first one. If
not, the second direction of orthotropy is deduced from the second
vector by removing its projection along the first one.

### Usage

~~~~{.cpp}
// using direction in 2D
@RotationMatrix<Direction> {0,1};
~~~~

~~~~{.cpp}
// using directions in 3D
@RotationMatrix<Direction> {{0,1,0},{1,0,0}};
~~~~

## Wrapper around behaviours written in the logarithmic strain framework generated with the `aster` interface {#sec:tfel_4.1:mtest:aster_logarithmic_strain_wrapper}

Behaviours written in the logarithmic strain framework and generated
with the `aster` interface were not handled by `MTest` because the
logarithmic strain framework is treated by `code_aster` and not by the
`aster` interface.

However, this is an issue for users using `MTest` for the identification
of the behaviour, as described in [Issue
#55](https://github.com/thelfer/tfel/issues/55).

`MTest` now automatically wraps the behaviour to handle those
behaviours. The wrapper handles the pre and post-processing steps around
the behaviour integration.

# Improvements to the `python` bindings 

## Improvements to the `TFEL/System` `python` module

### Retrieving information about behaviours' post-processings generated by the `generic` interface

The `generic` interface generates a function dedicated for each
initialize function and each modelling hypothesis supported (see Section
@sec:tfel_4.1:mfront:initialize_functions for details about initialize
functions).

The `ExternalLibraryManager` class now exposes the following methods:

- `getGenericBehaviourInitializeFunctionFunctions`, which returns the
  initialize functions associated with a behaviour.
- `getGenericBehaviourInitializeFunctionFunctionOutputs`, which returns the
  outputs of a initialize function function.
- `getGenericBehaviourInitializeFunctionFunctionOutputs`, which returns the
  types of the outputs of a initialize function function.

### Retrieving information about behaviours' post-processings generated by the `generic` interface

The `generic` interface generates a function dedicated for each
post-processing and each modelling hypothesis supported (see Section
@sec:tfel_4.1:mfront:postprocessings for details about
post-processings).

The `ExternalLibraryManager` class now exposes the following methods:

- `getGenericBehaviourPostProcessingFunctions`, which returns the
  post-processings associated with a behaviour.
- `getGenericBehaviourPostProcessingFunctionOutputs`, which returns the
  outputs of a post-processing function.
- `getGenericBehaviourPostProcessingFunctionOutputs`, which returns the
  types of the outputs of a post-processing function.

## Improvements to the `mtest` `python` module

## Support of named arguments in the constructor of the `Behaviour` class {#sec:tfel_4.1:pymtest:behaviour_constructor}

Named arguments are now supported in the `Behaviour` constructor. The
following arguments can be specified:

- `interface`: name of the interface to be used (optional).
- `library`: name of the shared library to be loaded.
- `function`: name of the function implementing the behaviour.
- `hypothesis`: hypothesis to be used.
- `wrapper`: name of the behaviour wrapper to be used (optional).

### Example of usage

The following piece of code loads a behaviour implemented in the
`src/libBehaviour.so` shared library by the `ImplicitNorton` function
for the `PlaneStrain` modelling hypothesis:

~~~~{.python}
b = mtest.Behaviour(library = 'src/libBehaviour.so',
                    function = 'ImplicitNorton',
                    hypothesis = 'PlaneStrain')
~~~~

## Exporting an `MTest`test to a `madnex` file {#sec:tfel:4.1:python:mtest:export_mtest_file}

The `TestDescription` data structure (see Section
@sec:tfel:4.1:mtest:TestDescription) and the `loadMTestFileContent` and
`write` functions (see Sections @sec:tfel:4.1:mtest:loadMTestFileContent
and @sec:tfel:4.1:mtest:write) are exposed in the `mtest` `python`
module.

### Example of usage {#sec:tfel:4.1:python:mtest:export_mtest_file:usage}

~~~~{.python}
import mtest

d = mtest.TestDescription()
d.author = 'John Doe'
d.date = '01/03/2022'
d.name = 'UniaxialTensileTest'
d.scheme = 'mtest'
d.behaviour = 'Plasticity'
mtest.loadMTestFileContent(d, 'Plasticity.mtest')

mtest.write(d,'Plasticity.mdnx')
~~~~

# `mfront-query` improvements

## New behaviour queries

### List of initialize functions

The list of initialize functions defined by a behaviour can be retrieved
using the `--initialize functions` query, as follows:

~~~~{.bash}
 mfront-query --initialize-functions Plasticity.mfront 
- ElasticStrainFromInitialStress: no description available.
~~~~

### List of initialize function variables

The list of initialize function' variables defined by a behaviour can be
retrieved using the `--initialize function-variables` query.

### List of post-processings

The list of post-processings defined by a behaviour can be retrieved
using the `--post-processings` query, as follows:

~~~~{.bash}
$ mfront-query --post-processings Elasticity.mfront 
- PrincipalStrain: compute the principal strain. Modified post-processing variables are:
  - PrincipalStrain (εᵖ)
~~~~

### List of post-processing variables

The list of post-processing' variables defined by a behaviour can be
retrieved using the `--post-processing-variables` query, as follows:

~~~~{.bash}
$ mfront-query --post-processing-variables Elasticity.mfront 
- PrincipalStrain (εᵖ)
~~~~

### List of `MTest` tests associated with a behaviour in a `madnex` file

The `--list-behaviour-mtest-tests` command line argument can be used to
display the list of tests associated with a behaviour in a `madnex`
file.

Optionnally, this command line argument accept the options
`sorted-by-behaviours` or `unsorted` (see the examples below).

#### Examples of usage

~~~~{.cxx}
$ mfront-query --list-behaviour-mtest-tests --test=".+Tensile.+" Plasticity.mdnx
- tests associated with behaviour Plasticity
    - UniaxialTensileTest
~~~~

~~~~{.cxx}
$ mfront-query --list-behaviour-mtest-tests=unsorted --test=".+Tensile.+" Plasticity.mdnx
UniaxialTensileTest
~~~~

# Issues fixed

## Issue #125: [mfront] Remove behaviour sources if not needed

For more details, see : <https://github.com/thelfer/tfel/issues/125>.

## Issue #124: [mfront] Add DSL option to disable runtime change of the out of bound policy

This feature is described in Section
@sec:tfel:4.1:mfront:global_options:out_of_bounds_policy_runtime_modification.

For more details, see : <https://github.com/thelfer/tfel/issues/124>.

## Issue #123: [mfront] Add DSL option to change the default out of bounds policy

This feature is described in Section
@sec:tfel:4.1:mfront:global_options:default_out_of_bounds_policy.

For more details, see : <https://github.com/thelfer/tfel/issues/123>.

## Issue #122: [mfront] remove usage of exceptions in the computeTangentOperator method generated by the `Implicit` DSL

For more details, see : <https://github.com/thelfer/tfel/issues/122>.

## Issue #111: [mtest] Support for `madnex` file

This feature is described in depth in Section @sec:tfel:4.1:mtest:madnex_support.

For more details, see : <https://github.com/thelfer/tfel/issues/111>.

## Issue #108: [mtest] Support for extended types in MTest

For more details, see : <https://github.com/thelfer/tfel/issues/108>.

## Issue 94: [mfront] Add option to disable initialization of parameters from text file

This feature is described in Section
@sec:tfel:4.1:mfront:global_options:parameters_initialization_from_file.

For more details, see : <https://github.com/thelfer/tfel/issues/94>.

## Issue 91: [mfront] define build identifier using options

This feature is described in Section
@sec:tfel:4.1:mfront:global_options:build_identifier.

For more details, see : <https://github.com/thelfer/tfel/issues/91>.

## Issue #83: [mfront] Add a command line argument to retrieve the list of options associated with a domain specific language

This feature is described in Section
@sec:tfel_4.1:mfront:list_dsl_options.

For more details, see : <https://github.com/thelfer/tfel/issues/83>.

## Issue #82: [mfront] Ability to define DSL options on the command line

This feature is described in Section
@sec:tfel_4.1:mfront:global_dsl_options.

For more details, see : <https://github.com/thelfer/tfel/issues/82>.

## Issue #55: [mtest] Creation of a wrapper around behaviours written in the logarithmic strain framework generated with the `aster` interface

The wrapper is described in Section
@sec:tfel_4.1:mtest:aster_logarithmic_strain_wrapper.

For more details, see : <https://github.com/thelfer/tfel/issues/55>.

## Issue #57: [gallery] Mistakes in the Drucker Prager Cap model of the gallery

For more details, see : <https://github.com/thelfer/tfel/issues/57>.

## Issue #50: [mfront] Options to avoid the automatic declaration of the temperature as an external state variable {#sec:tfel:4.1:issue:50}

This option is described in depth in Section
@sec:tfel:4.1:mfront:global_options:temperature_as_first_external_state_variable.

For more details, see : <https://github.com/thelfer/tfel/issues/50>.

## Issue #44: [mtest] Add support for a boundary condition modelling the effet of a mandrel in pipe modelling

The feature is described in Section @sec:tfel_4.1:mtest:mandrel.

For more details, see : <https://github.com/thelfer/tfel/issues/38>.

## Issue #39: [tfel-config] Add query associated with python bindings support

`tfel-config` now supports an command line option named
`--python-bindings-support` which displays true if `python` bindings are
available, `false` otherwise.

For more details, see : <https://github.com/thelfer/tfel/issues/39>.

## Issue #38: [tfel-config] Add query associated with `madnex` support

`tfel-config` now supports an command line option named
`--madnex-support` which displays true if `madnex` files are supported,
`false` otherwise.

For more details, see : <https://github.com/thelfer/tfel/issues/38>.

## Issue #36: [mfront] Improved support for `MTest` file generation (all kind of state variables)

In previous versions, only scalar and symmetric tensors state variables
were supported when generation `MTest` file on integration failure.

All kind of state variables are now supported.

For more details, see : <https://github.com/thelfer/tfel/issues/36>.

## Issue #28: [mtest] Support of tensorial external state variables

The `Behaviour` class has new methods:

- `expandExternalStateVariablesNames` (wrapped in python)
- `getExternalStateVariableType`  (wrapped in python)
- `getExternalStateVariablePosition` (wrapped in python)

The `@ExternalStateVariable` now allows to define tensorial external
state variables components by components or an array as follows:

~~~~{.cpp}
// Definition of an symmetric tensor external state variable
@ExternalStateVariable<function> "g" {"0", "1", "2", "3 * t", "4", "5 * t"};
// Definition of an symmetric tensor external state variable components by components
@ExternalStateVariable<function> "g2XX"  "0";
@ExternalStateVariable<function> "g2YY"  "2";
@ExternalStateVariable<function> "g2ZZ"  "t";
@ExternalStateVariable<function> "g2XY"  "3";
@ExternalStateVariable<function> "g2XZ"  "4";
@ExternalStateVariable<function> "g2YZ"  "5*t";
~~~~

For more details, see : <https://github.com/thelfer/tfel/issues/28>.

## Issue #28: [mtest] Support of tensorial external state variables

For more details, see : <https://github.com/thelfer/tfel/issues/28>.

## Issue #27: [mfront] Better support of tensorial external state variables

The type of the external state variables are now exported.

- `ExternalLibraryManager` has a new method called
  `getUMATExternalStateVariablesTypes` (wrapped in `python`)
- `ExternalBehaviourDescription` has a new method called `evtypes`
  (wrapped in `python`)

Generation of `MTest` file also supports tensor external state variables.

For more details, see : <https://github.com/thelfer/tfel/issues/27>.

## Issue #26: Don't use explicit instanciation for static variables

For more details, see : <https://github.com/thelfer/tfel/issues/26>.

## Issue #25: [mfront] Add ability to define initialisation functions

This feature is described in Section
@sec:tfel_4.1:mfront:initialize_functions.

For more details, see : <https://github.com/thelfer/tfel/issues/25>.

## Issue #24: [mfront] Add ability to define post-processings

This feature is described in Section
@sec:tfel_4.1:mfront:postprocessings.

For more details, see : <https://github.com/thelfer/tfel/issues/24>.

## Issue #23: [mfront] Remove usage of C++ reserved variables names

Some exported variables used to contain a double underscore in their
names. Such names are reserved by the C++ standard for internal use by
the compilers.

For more details, see : <https://github.com/thelfer/tfel/issues/23>.

## Issue #22 : [mfront] Option to treat parameters as static variables

This option is described in depth in Section
@sec:tfel:4.1:mfront:global_options:parameters_as_static_variables.

For more details, see : <https://github.com/thelfer/tfel/issues/22>.

## Issue #20: [mtest] Declaration of a behaviour wrapper in python module

As described in Section @sec:tfel_4.1:pymtest:behaviour_constructor,
named parameters are now supported in the constructor of the `Behaviour`
class. The (optional) `wrapper` argument can now be used to specify a
behaviour wrapper.

Currently, two behaviours wrappers are available:

- `LogarithmicStrain1D`: which turns a small strain behaviour in
  axisymmetrical generalised plane strain into a finite strain behaviour
  in the logarithmic strain framework following the ETO-PK1 kinematic
  assumption used by the `MTest` for the simulation of pipe in finite
  strain.
- `SmallStrainTridimensionalBehaviourWrapper` which allows to use a
  small strain tridimensional behaviour under the following modelling
  hypotheses: axisymmetrical generalised plane strain, plane strain,
  axisymmetry.

For more details, see : <https://github.com/thelfer/tfel/issues/20>.

## Issue #18: [mtest] Usage of a `3D` behaviour in `ptest`

Thanks the `SmallStrainTridimensionalBehaviourWrapper` class detailled
in Section
@sec:tfel_4.1:mtest:small_strain_tridimensional_behaviour_wrapper,
tridimensional behaviours can be used under the following modelling
hypotheses: generalised plane strain, plane strain, axisymmetrical
generalised plane strain.

For more details, see : <https://github.com/thelfer/tfel/issues/18>.

## Issue #15: [mtest] New option for the declaration of the rotation matrix in `MTest`

This option is described in depth in Section
@sec:tfel_4.1:mtest:rotation_matrix.

For more details, see : <https://github.com/thelfer/tfel/issues/15>.

<!--
# References
-->